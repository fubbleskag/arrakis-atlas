
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is an actual owner of a map
    function isActualOwner(userId, mapData) {
      return mapData.ownerId == userId && mapData.collaborators[userId] == 'owner';
    }

    // Helper function to check if a user is an actual co-owner of a map
    function isActualCoOwner(userId, mapData) {
      return mapData.collaborators[userId] == 'co-owner';
    }

    // Helper function to check if a user is an actual associate of a map
    function isActualAssociate(userId, mapData) {
      return mapData.collaborators[userId] == 'associate';
    }

    // Helper function to validate the structure of MapData
    function isValidMapStructure(data) {
      return data.name is string && data.name.size() > 0 && data.name.size() <= 100 &&
             data.ownerId is string && data.ownerId.size() > 0 &&
             data.memberUIDs is list && data.ownerId in data.memberUIDs &&
             data.collaborators is map && data.ownerId in data.collaborators.keys() &&
             data.collaborators[data.ownerId] == 'owner' &&
             // Ensure all collaborators are members and all members (except public viewers) have a collaborator entry
             data.memberUIDs.hasOnly(data.collaborators.keys()) && data.collaborators.keys().hasAll(data.memberUIDs) &&
             data.collaborators.values().hasAny(['owner', 'co-owner', 'associate']) && // Check for valid roles
             data.isPublic is bool &&
             data.gridState is map &&
             // Example: Check if gridState has row keys "0" through "8"
             // This can be expanded to check cell structure if needed, but can become complex/costly
             ('0' in data.gridState.keys()) && // Simplified check for brevity
             data.createdAt is timestamp &&
             data.updatedAt is timestamp;
    }

    match /users/{userId} {
      allow read: if request.auth != null; // Allows authenticated users to read profiles (e.g., for email lookup)
      allow create: if request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       (request.resource.data.displayName == request.auth.token.name || request.resource.data.displayName == null) &&
                       request.resource.data.lastLogin == request.time;
      allow update: if request.auth.uid == userId &&
                       request.resource.data.uid == userId && // uid cannot change
                       request.resource.data.email == request.auth.token.email && // email can be updated if auth token reflects it
                       // Allow displayName to be updated
                       request.resource.data.lastLogin == request.time && // lastLogin updated on every write
                       // Prevent other fields from being added/changed
                       request.resource.data.keys().hasOnly(['uid', 'email', 'displayName', 'lastLogin']);
    }

    match /maps/{mapId} {
      let ownerEditableFields = ['name', 'isPublic', 'gridState', 'collaborators', 'memberUIDs', 'ownerId'];
      let coOwnerEditableFields = ['name', 'isPublic', 'gridState', 'collaborators', 'memberUIDs'];
      let associateEditableFields = ['gridState']; // Associates can only edit the grid

      allow read: if resource.data.isPublic == true || (request.auth != null && request.auth.uid in resource.data.memberUIDs);

      allow create: if request.auth.uid == request.resource.data.ownerId &&
                       request.auth.uid in request.resource.data.memberUIDs &&
                       request.resource.data.memberUIDs.size() == 1 &&
                       request.resource.data.collaborators[request.auth.uid] == 'owner' &&
                       request.resource.data.collaborators.size() == 1 &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       isValidMapStructure(request.resource.data);

      allow update: if request.auth != null && request.auth.uid in resource.data.memberUIDs &&
                       isValidMapStructure(request.resource.data) &&
                       request.resource.data.createdAt == resource.data.createdAt && // createdAt is immutable
                       request.resource.data.updatedAt == request.time { // updatedAt must be set to server time

                        let changedKeys = request.resource.data.diff(resource.data).affectedKeys().removeAll(['updatedAt']);

                        // Case 1: Owner Transfer
                        // Initiated by current owner, ownerId is changing.
                        if (resource.data.ownerId == request.auth.uid &&
                            request.resource.data.ownerId != resource.data.ownerId &&
                            request.resource.data.collaborators[request.resource.data.ownerId] == 'owner' && // New owner has 'owner' role
                            request.resource.data.collaborators[resource.data.ownerId] == 'co-owner' && // Old owner becomes 'co-owner'
                            request.resource.data.memberUIDs.hasAll([request.resource.data.ownerId, resource.data.ownerId]) && // Both involved UIDs are members
                            changedKeys.hasOnly(['ownerId', 'collaborators', 'memberUIDs']) // Only these fields can change during owner transfer
                           ) {
                          allow update: true;
                        }
                        // Case 2: Regular Edits (Owner, Co-Owner, Associate)
                        // ownerId is NOT changing, and original owner must remain 'owner'.
                        else if (request.resource.data.ownerId == resource.data.ownerId &&
                                 request.resource.data.collaborators[resource.data.ownerId] == 'owner'
                                ) {
                          // Owner edits
                          if (isActualOwner(request.auth.uid, resource.data) &&
                              changedKeys.removeAll(['createdAt', 'ownerId']).hasOnly(ownerEditableFields.removeAll(['ownerId']))) { // Owner can edit all their fields except transferring ownership this way
                             allow update: true;
                          }
                          // Co-Owner edits
                          else if (isActualCoOwner(request.auth.uid, resource.data) &&
                                   changedKeys.removeAll(['createdAt', 'ownerId']).hasOnly(coOwnerEditableFields) && // Co-owner cannot change ownerId
                                   !(request.resource.data.ownerId != resource.data.ownerId) // double check ownerId not changed
                                  ) {
                             allow update: true;
                          }
                          // Associate edits
                          else if (isActualAssociate(request.auth.uid, resource.data) &&
                                   changedKeys.removeAll(['createdAt', 'ownerId', 'name', 'isPublic', 'collaborators', 'memberUIDs']).hasOnly(associateEditableFields) && // Associate can only edit gridState
                                   !(request.resource.data.ownerId != resource.data.ownerId) // double check ownerId not changed
                                  ) {
                             allow update: true;
                          }
                          else {
                            allow update: false;
                          }
                        }
                        else {
                          allow update: false;
                        }
                       }

      allow delete: if request.auth != null && request.auth.uid == resource.data.ownerId;
    }
  }
}
