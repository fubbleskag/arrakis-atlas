rules_version = '2';

service cloud.firestore {

	match /databases/{database}/documents {

		// Helper function: Checks if the user is authenticated
		function isAuthenticated() {
			return request.auth != null;
		}

		// Helper function: Checks if the authenticated user is the owner of the map
		function isMapOwner(mapData) {
			return isAuthenticated() && request.auth.uid == mapData.ownerId;
		}

		// Helper function: Checks if the authenticated user is an editor of the map
		function isMapEditor(mapData) {
			return mapData.keys().hasAny(['editors']) && request.auth.uid in mapData.editors;
		}

		// Helper function: Validates data for a new user profile
		function isValidNewUserProfile(data) {
			return data.keys().hasAll(['email', 'displayName', 'lastLogin'])
				&& (data.email is string || data.email == null)
				&& (data.displayName is string || data.displayName == null)
				&& data.lastLogin == request.time; // Enforce server timestamp on creation
		}

		// Helper function: Validates data for an updated user profile
		function isValidUpdatedUserProfile(data) {
			return data.keys().hasAll(['email', 'displayName', 'lastLogin'])
				&& (data.email is string || data.email == null)
				&& (data.displayName is string || data.displayName == null)
				&& data.lastLogin == request.time; // Enforce server timestamp on update
		}

		// Helper function: Validates the structure and initial values for a new map
		function isValidNewMap(data) {
			return data.keys().hasAll(['ownerId', 'name', 'gridState', 'createdAt', 'updatedAt', 'isPublicViewable', 'publicViewId', 'collaboratorShareId', 'editors'])
				&& data.ownerId == request.auth.uid
				&& data.name is string && data.name.size() > 0 && data.name.size() < 100
				&& data.gridState is map
				&& data.createdAt == request.time
				&& data.updatedAt == request.time
				&& data.isPublicViewable == false
				&& data.publicViewId == null
				&& data.collaboratorShareId == null
				&& data.editors is list && data.editors.size() == 0;
		}

		// Helper function: Validates data for an updated map
		// Note: gridState can be complex, so we're only checking its type here.
		// More granular validation for gridState might be needed if specific structures are critical.
		function isValidUpdatedMap(newData, oldData) {
			return newData.ownerId == oldData.ownerId // ownerId cannot change
				&& newData.name is string && newData.name.size() > 0 && newData.name.size() < 100
				&& newData.gridState is map
				&& newData.createdAt == oldData.createdAt // createdAt cannot change
				&& newData.updatedAt == request.time
				&& newData.isPublicViewable is bool
				&& (newData.publicViewId is string || newData.publicViewId == null)
				&& (newData.collaboratorShareId is string || newData.collaboratorShareId == null)
				&& newData.editors is list;
				// Add more specific validation for editors array elements if needed (e.g., all strings)
		}

		// Helper function: Validates updates made by an editor
		function isValidEditorUpdate(requestData, existingMapData) {
			// requestData is request.resource.data, containing fields the client is trying to write.
			// existingMapData is resource.data, the current document in Firestore.

			// 1. Check that the client is only trying to write 'gridState' and/or 'updatedAt'.
			//    No other fields should be present in the write request from an editor.
			let writeKeys = requestData.keys();
			let allowedWriteKeysForEditor = ['gridState', 'updatedAt'];
			// Check if writeKeys is a subset of or equal to allowedWriteKeysForEditor
			let onlyAllowedKeysAreWritten = writeKeys.hasOnly(allowedWriteKeysForEditor) || writeKeys.hasOnly(['gridState']);

			// 2. Ensure 'gridState' is actually part of the fields being written.
			//    An editor must be intending to update the grid.
			let gridStateIsBeingWritten = 'gridState' in requestData;

			// 3. If 'updatedAt' is being written by the client, ensure it's set to the server timestamp.
			//    Your client-side MapContext logic ensures updatedAt: serverTimestamp() is added.
			//    In rules, serverTimestamp() resolves to request.time.
			let timestampIsValid = !('updatedAt' in requestData) || requestData.updatedAt == request.time;

			return onlyAllowedKeysAreWritten && gridStateIsBeingWritten && timestampIsValid;
		}

		// Rules for user profiles
		match /users/{userDocId} {

			allow read: if isAuthenticated() && request.auth.uid == userDocId;

			allow create: if isAuthenticated() && request.auth.uid == userDocId
			&& isValidNewUserProfile(request.resource.data);

			allow update: if isAuthenticated() && request.auth.uid == userDocId
			&& isValidUpdatedUserProfile(request.resource.data);

			allow delete: if false; // Typically users don't delete their own profiles

		}

		// Rules for maps
		match /maps/{mapId} {

			// READ: Allow if public, or if authenticated user is owner or an editor.
			allow read: if resource.data.isPublicViewable == true ||
			(isAuthenticated() && (isMapOwner(resource.data) || isMapEditor(resource.data)));

			// CREATE: Allow if authenticated and new map data is valid (as per your isValidNewMap).
			allow create: if isAuthenticated() && isValidNewMap(request.resource.data);

			// UPDATE:
			// - Owners can update based on your isValidUpdatedMap function.
			// - Editors can update based on the new isValidEditorUpdate function.
			allow update: if isAuthenticated() && (
			(isMapOwner(resource.data) && isValidUpdatedMap(request.resource.data, resource.data)) ||
			(isMapEditor(resource.data) && isValidEditorUpdate(request.resource.data, resource.data))
			);

			// DELETE: Allow only if authenticated user is the owner.
			allow delete: if isAuthenticated() && isMapOwner(resource.data);

		}

		// == Rules for 'users' collection (example, adjust as needed) ==
		match /users/{userId} {

			// Users can read and write their own profile.
			allow read, write: if isAuthenticated() && request.auth.uid == userId;

		}

	}

}