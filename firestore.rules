
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUserProfile(data) {
      return data.uid is string &&
             (data.email == null || data.email is string) &&
             (data.displayName == null || data.displayName is string) &&
             (data.lastLogin == null || data.lastLogin is timestamp);
    }

    function isValidTimestamp(ts) {
      return ts is timestamp && ts == request.time;
    }

    // Map specific helpers
    function isOwner(authUid, mapData) {
      return authUid == mapData.ownerId;
    }

    function isCoOwner(authUid, mapData) {
      return mapData.collaborators[authUid] == 'co-owner';
    }

    function isAssociate(authUid, mapData) {
      return mapData.collaborators[authUid] == 'associate';
    }

    function isMember(authUid, mapData) {
      return authUid in mapData.memberUIDs;
    }
    
    function isOneOwner(collaborators, ownerId) {
      return collaborators[ownerId] == 'owner' &&
             collaborators.filter((uid, role) => role == 'owner').size() == 1;
    }

    function isValidMapStructure(data) {
      return data.name is string && data.name.size() > 0 && data.name.size() < 100 &&
             data.ownerId is string &&
             data.memberUIDs is list && data.memberUIDs.size() > 0 &&
             data.collaborators is map && data.collaborators.size() > 0 &&
             data.isPublic is bool &&
             data.gridState is map &&
             // Ensure all memberUIDs are strings and owner is a member
             data.memberUIDs.hasAll([data.ownerId]) &&
             data.memberUIDs.size() == data.memberUIDs.filter(uid => uid is string).size() &&
             // Ensure collaborator keys are strings (UIDs) and values are valid roles
             data.collaborators.keys().size() == data.collaborators.keys().filter(k => k is string).size() &&
             data.collaborators.values().hasOnly(['owner', 'co-owner', 'associate']) &&
             // Owner must be in collaborators with 'owner' role and only one owner
             isOneOwner(data.collaborators, data.ownerId) &&
             // All UIDs in collaborators map must also be in memberUIDs list
             data.memberUIDs.hasAll(data.collaborators.keys()) &&
             // All UIDs in memberUIDs list must also be in collaborators map (ensures they are the same set of people, plus potentially public)
             data.collaborators.keys().hasAll(data.memberUIDs) &&
             // Basic GridState check: keys are strings (e.g., "0", "1")
             (data.gridState.size() == 0 || data.gridState.keys().size() == data.gridState.keys().filter(k => k is string).size());
             // Add more detailed gridState cell validation if necessary
    }

    // Let bindings for field lists (allowed at this scope)
    let ownerEditableFields = ['name', 'gridState', 'isPublic', 'collaborators', 'memberUIDs', 'ownerId'];
    let coOwnerEditableFields = ['name', 'gridState', 'isPublic', 'collaborators', 'memberUIDs'];
    let associateEditableFields = ['gridState']; // Changed from ['name', 'gridState'] as per typical associate role. Adjust if 'name' is also desired.


    // Users Collection
    match /users/{userId} {
      allow read: if isAuthenticated(); // Allow authenticated users to read profiles (e.g., for email lookup)
      allow create: if isAuthenticated() && request.auth.uid == userId &&
                       isUserProfile(request.resource.data) &&
                       isValidTimestamp(request.resource.data.lastLogin);
      allow update: if isAuthenticated() && request.auth.uid == userId &&
                       isUserProfile(request.resource.data) &&
                       request.resource.data.uid == resource.data.uid && // uid immutable
                       isValidTimestamp(request.resource.data.lastLogin);
    }

    // Maps Collection
    match /maps/{mapId} {
      allow read: if resource.data.isPublic == true || (isAuthenticated() && isMember(request.auth.uid, resource.data));

      allow create: if isAuthenticated() &&
                       request.auth.uid == request.resource.data.ownerId &&
                       request.resource.data.memberUIDs == [request.auth.uid] &&
                       request.resource.data.collaborators == {request.auth.uid: 'owner'} &&
                       isValidTimestamp(request.resource.data.createdAt) &&
                       isValidTimestamp(request.resource.data.updatedAt) &&
                       request.resource.data.createdAt == request.resource.data.updatedAt &&
                       isValidMapStructure(request.resource.data);

      allow delete: if isAuthenticated() && isOwner(request.auth.uid, resource.data);

      // Update Logic
      allow update: if
        // Common Pre-conditions
        isAuthenticated() &&
        isMember(request.auth.uid, resource.data) && // User must be a current member
        request.resource.data.createdAt == resource.data.createdAt && // createdAt is immutable
        isValidTimestamp(request.resource.data.updatedAt) &&
        isValidMapStructure(request.resource.data) && // New structure must be valid

        // Field Change Logic
        (
          // Case 1: Owner Transfer
          ( request.resource.data.ownerId != resource.data.ownerId && // ownerId is actually changing
            isOwner(request.auth.uid, resource.data) && // Only current owner can initiate transfer
            request.resource.data.collaborators[request.resource.data.ownerId] == 'owner' && // New owner gets 'owner' role in new data
            (resource.data.ownerId == request.auth.uid ? request.resource.data.collaborators[resource.data.ownerId] == 'co-owner' : true) && // Old owner (if not new owner) becomes co-owner
            isMember(request.resource.data.ownerId, request.resource.data) && // New owner must be a member in new data
            request.resource.data.diff(resource.data).affectedKeys().removeAll(['updatedAt']).hasOnly(['ownerId', 'collaborators', 'memberUIDs']) // Only specific fields allowed during transfer
          ) ||
          // Case 2: Not an Owner Transfer - Regular Edits
          ( request.resource.data.ownerId == resource.data.ownerId &&
            (
              // Owner edits
              (isOwner(request.auth.uid, resource.data) &&
                request.resource.data.diff(resource.data).affectedKeys().removeAll(['updatedAt', 'ownerId', 'createdAt']).hasAny(ownerEditableFields.removeAll(['ownerId']))
              ) ||
              // Co-Owner edits
              (isCoOwner(request.auth.uid, resource.data) &&
                request.resource.data.collaborators[resource.data.ownerId] == 'owner' && // Ensure original owner remains owner
                request.resource.data.diff(resource.data).affectedKeys().removeAll(['updatedAt', 'ownerId', 'createdAt']).hasOnly(coOwnerEditableFields.removeAll(['ownerId']))
              ) ||
              // Associate edits
              (isAssociate(request.auth.uid, resource.data) &&
                request.resource.data.collaborators[resource.data.ownerId] == 'owner' && // Ensure original owner remains owner
                request.resource.data.diff(resource.data).affectedKeys().removeAll(['updatedAt', 'ownerId', 'createdAt']).hasOnly(associateEditableFields.removeAll(['ownerId']))
              )
            )
          )
        );
    }
  }
}
